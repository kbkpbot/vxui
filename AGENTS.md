# vxui Project Guide

## Project Overview

**vxui** is a cross-platform desktop UI framework that uses V as the backend and your browser as the display. It communicates via WebSocket, with no HTTP/HTTPS server required.

### Core Philosophy
- Use the browser that comes with every desktop system as the UI display layer
- Use WebSocket instead of traditional HTTP requests for true bidirectional real-time communication
- Frontend can be developed with HTML + CSS + JS, combined with htmx framework
- Backend written in pure V language

### Tech Stack
- **Backend**: V Language (vlang.io)
- **Frontend**: HTML + CSS + JavaScript
- **Communication**: WebSocket
- **Frontend Framework**: htmx (official version) + vxui-ws.js

---

## Project Structure

```
/home/mars/.vmodules/vxui/
├── v.mod               # V module definition file
├── README.md           # Project documentation
├── CHANGELOG.md        # Version history
├── LICENSE             # MIT License
├── vxui.png            # Architecture diagram
├── src/
│   ├── vxui.v          # Main framework: WebSocket server, routing, run_js, multi-client
│   ├── browser.v       # Browser detection and launching
│   ├── embed.v         # Packed app support for single executable distribution
│   ├── utils.v         # Utility and security functions
│   └── vxui_test.v     # Unit tests
├── doc/
│   └── vxui.md         # API documentation (generated by vdoc)
├── js/
│   ├── htmx.js         # htmx library (official version 2.0.7)
│   └── vxui-ws.js      # vxui WebSocket extension (Token auth, auto-reconnect, run_js)
└── examples/
    ├── test/           # Basic example: form handling, button interaction
    ├── packed/         # Single executable example: embedded resources
    ├── enchart/        # Advanced example: ECharts real-time data visualization
    ├── gallery/        # Desktop UI controls demo
    ├── element-plus/   # Vue 3 + Element Plus integration demo
    ├── todo-app/       # Full CRUD example
    └── file-upload/    # File upload/download example
```

---

## Core Architecture

### Workflow

1. **Start Application**:
   - Find available port
   - Start WebSocket server listening on that port
   - Generate security token
   - Launch Chrome browser and load the initial HTML file

2. **Communication Mechanism**:
   - Frontend establishes WebSocket connection via `vxui-ws.js`
   - Client authenticates with token
   - All htmx triggers (hx-post, hx-get, etc.) are converted to WebSocket messages
   - Backend processes requests and returns HTML fragments, frontend performs partial updates

3. **Message Format**:
   ```json
   {
     "verb": "post",
     "path": "/clicked",
     "elt": "BUTTON",
     "parameters": {},
     "HEADERS": {
       "HX-Request": "true",
       "HX-Trigger": null,
       "HX-Trigger-Name": null,
       "HX-Target": null,
       "HX-Current-URL": "file:///..."
     }
   }
   ```

### Key Components

| Component | Description |
|-----------|-------------|
| `Context` | Main struct, contains WebSocket port, server instance, route mapping |
| `Route` | Route definition, contains HTTP verb and path |
| `Verb` | Enum type: get, post, put, delete, patch, any_verb |
| `run[T]()` | Startup function, opens browser and runs event loop |

---

## Usage

### Installation

```bash
v install --git https://github.com/kbkpbot/vxui.git
```

### Create Application

```v
module main

import vxui
import x.json2

// 1. Inherit from vxui.Context
struct App {
    vxui.Context
mut:
    counter int
}

// 2. Define route handler
@['/submit']  // Specify path
fn (mut app App) submit(message map[string]json2.Any) string {
    app.counter++
    // Return HTML fragment, supports hx-swap-oob for partial updates
    return '<div id="result" hx-swap-oob="true">Count: ${app.counter}</div>'
}

// 3. If attribute is omitted, function name is used as path
fn (mut app App) hello(message map[string]json2.Any) string {
    return '<div>Hello from vxui!</div>'
}

fn main() {
    mut app := App{}
    app.close_timer = 1000  // Auto close after 1000ms with no client
    app.logger.set_level(.debug)
    vxui.run(mut app, './ui/index.html')!
}
```

### Frontend HTML

```html
<!DOCTYPE html>
<html>
<head>
    <script src="./js/htmx.js"></script>
    <script src="./js/vxui-ws.js"></script>
</head>
<body hx-ext="vxui-ws">
    <!-- hx-post triggers WebSocket request to /submit -->
    <button hx-post="/submit" hx-swap="outerHTML">
        Click Me
    </button>
    <div id="result"></div>
</body>
</html>
```

---

## Key Configuration Options

### Context Struct

```v
struct Context {
mut:
    ws_port u16              // WebSocket listening port
    ws      websocket.Server // WebSocket server instance
    routes  map[string]Route // Route mapping
pub mut:
    close_timer  int = 50    // Wait time before auto-close when no browser connection (ms)
    logger       &log.Log    // Logger
    token        string      // Security token for client authentication
    multi_client bool        // Allow multiple clients
    window       WindowConfig // Window configuration
    browser      BrowserConfig // Browser startup configuration
}
```

### BrowserConfig

```v
struct BrowserConfig {
pub mut:
    custom_args       []string // Additional custom arguments
    profile_dir       string   // Custom profile directory (empty = default)
    headless          bool     // Run in headless mode (for testing)
    devtools          bool     // Open DevTools automatically
    no_sandbox        bool     // Disable sandbox (for root/CI)
    user_data_dir     string   // Custom user data directory
    preferred_path    string   // Preferred browser path (skip detection)
    remote_debug_port int      // Chrome remote debugging port (e.g., 9222)
}
```

### Attribute Tags

- `['/path']` - Specify route path
- `['get']`, `['post']`, `['put']`, `['delete']`, `['patch']` - Specify HTTP verb
- Can be combined: `['/api', 'post']`

---

## New Features

### Token Authentication

vxui now supports token-based authentication for secure client connections:

```v
fn main() {
    mut app := App{}
    // Token is auto-generated, or set manually:
    // app.token = 'my-secret-token'
    vxui.run(mut app, './ui/index.html')!
}
```

The token is passed to the browser via URL parameter and used for all WebSocket communications.

### run_js() - Execute JavaScript from Backend

Execute JavaScript code in the frontend and get the result:

```v
// Execute JS on first connected client
result := app.run_js('document.title', 5000)!  // 5 second timeout
println('Page title: ${result}')

// Execute on specific client
result := app.run_js_client(client_id, 'alert("Hello!")', 3000)!
```

### Multi-Client Support

```v
// Enable multiple clients
app.multi_client = true

// Get connected clients
clients := app.get_clients()
count := app.get_client_count()

// Broadcast to all clients
app.broadcast('<div hx-swap-oob="true">Server message</div>')!

// Close specific client
app.close_client(client_id)!
```

### Window Management API

```v
// Set window size
app.set_window_size(1024, 768)

// Set window position (-1 for center)
app.set_window_position(100, 100)

// Set window title
app.set_window_title('My App')

// Configure via WindowConfig
app.window = vxui.WindowConfig{
    width: 1200
    height: 800
    resizable: true
}
```

### Chrome Remote Debugging

Enable Chrome DevTools Protocol for debugging:

```v
fn main() {
    mut app := App{}
    // Enable remote debugging on port 9222
    app.Context.config.browser.remote_debug_port = 9222
    vxui.run(mut app, './ui/index.html')!
}
```

**Features:**
- Connect Chrome DevTools via `http://localhost:9222`
- Inspect elements, view console logs, debug JavaScript
- Useful when F12 is disabled in app mode

**Usage:**
1. Start your vxui application with `remote_debug_port` set
2. Open Chrome and navigate to `http://localhost:9222`
3. Click on the page to inspect
4. Full DevTools panel will open

### OOB Update Command (Multi-Client Broadcast)

Broadcast HTML updates to all connected clients:

```v
// Backend: broadcast HTML with CSS variable data
oob_html := '<div id="main-wrapper" hx-swap-oob="true" 
    data-bg="#ff0000" data-accent="#00ff00" data-font-size="18">
    ...content...
</div>'

broadcast_msg := json2.encode({
    'cmd':  'oob_update'
    'html': oob_html
})
app.broadcast(broadcast_msg)!
```

**Frontend (vxui-ws.js):**
- Automatically handles `oob_update` command
- Performs OOB swap using htmx internal APIs
- Updates CSS variables from `data-bg`, `data-accent`, `data-font-size` attributes
- Rebinds htmx event listeners on new elements

### Single Executable Distribution

Embed frontend files into the binary for easy distribution:

```v
module main

import vxui

// Embed files at compile time using V's $embed_file
const index_html = $embed_file('ui/index.html')
const app_js = $embed_file('ui/app.js')
const style_css = $embed_file('ui/style.css')

struct App {
    vxui.Context
}

fn main() {
    mut app := App{}
    
    // Create packed app
    mut packed := vxui.new_packed_app()
    packed.add_file_string('index.html', index_html.to_string())
    packed.add_file_string('js/app.js', app_js.to_string())
    packed.add_file_string('css/style.css', style_css.to_string())
    
    // Run with packed resources
    vxui.run_packed(mut app, mut packed, 'index.html')!
}
```

Build:
```bash
v -prod main.v           # Production build
v -prod -compress main.v # Smaller binary
```

Result: Single executable (~1.4 MB) containing all frontend assets!

---

## Examples

### examples/test - Basic Interaction

Demonstrates:
- Form submission and data binding
- Dynamic edit/cancel mode switching
- Multi-parameter handling
- Keyboard shortcuts (alt+shift+D)

### examples/packed - Single Executable

Demonstrates:
- Using `$embed_file` to embed frontend files
- Building a self-contained executable
- No external files needed for distribution

### examples/enchart - Real-time Charts

Demonstrates:
- Fetching random data from backend every second
- ECharts real-time chart rendering
- JSON data communication

---

## Development Guidelines

### Backend Development

1. **Struct Definition**: Must embed `vxui.Context`
2. **Handler Functions**:
   - Receive `(mut app T)` as receiver
   - Parameter is `message map[string]json2.Any`
   - Return `string` (HTML fragment)
3. **Return Value**: Use `hx-swap-oob="true"` for out-of-band swap to update specific elements

### Frontend Development

1. **Required Scripts**:
   - `htmx.js` - Core library
   - `vxui-ws.js` - vxui WebSocket extension (supports Token authentication)

2. **htmx Attributes**:
   - `hx-post`, `hx-get`, `hx-put`, `hx-delete` - Trigger requests
   - `hx-swap` - Specify swap method (innerHTML, outerHTML, beforeend, etc.)
   - `hx-swap-oob` - Out-of-band swap, update non-trigger elements
   - `hx-trigger` - Custom trigger conditions

---

## Build and Run

### Run Examples

```bash
# Enter example directory
cd examples/test

# Run example
v run main.v

# Or specify HTML file
v run main.v ./ui/custom.html
```

### Development Debugging

```v
// Enable verbose logging
app.logger.set_level(.debug)
app.logger.set_output_stream(os.stderr())
app.logger.set_short_tag(true)
app.logger.set_custom_time_format('HH:mm:ss')
```

---

## Notes

1. **Alpha Stage**: Project is in early development stage, APIs may change
2. **Browser Support**: Currently mainly supports Chrome (with specific startup parameters)
3. **No HTTP Server**: All communication via WebSocket, files loaded via `file://` protocol
4. **Auto Close**: Application will auto-exit after `close_timer` time when no browser client is connected
5. **Chrome Startup Parameters**: Uses independent user data directory, disables cache and extensions

---

## License

MIT License

---

## Related Links

- Project Repository: https://github.com/kbkpbot/vxui
- V Language: https://vlang.io
- htmx: https://htmx.org